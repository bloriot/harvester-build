#!/bin/bash
# ============================================================================
# Script: build-efi-raw-image.sh
# Description: Create a compressed raw disk image with EFI/UEFI boot for Harvester
# ============================================================================
# This script automates the creation of a raw disk image pre-installed with
# Harvester, configured for EFI/UEFI boot instead of legacy BIOS boot.
#
# Features:
# - Automatic version detection from ISO files
# - Automatic OVMF (UEFI) firmware detection
# - Creation of a QEMU VM with EFI boot
# - Automatic installation of Harvester
# - Compression of the resulting image
#
# Prerequisites:
# - Harvester ISO already built (via 'make')
# - QEMU installed (qemu-system-x86_64)
# - OVMF installed (qemu-ovmf-x86_64 or equivalent)
# - KVM enabled and accessible by the user
# - zstd installed for compression
# ============================================================================

# Strict mode: stop the script on the first error
# Useful to avoid continuing with silent errors
set -e

# ============================================================================
# Configuration Variables
# ============================================================================
# VERSION: Harvester Version (e.g., "v1.7.0")
#   - If empty: automatic detection from ISO files
#   - If defined: uses this version explicitly
VERSION=""

# PROJECT_PREFIX: Prefix for generated files
# Format: "harvester-{VERSION}" (e.g., "harvester-v1.7.0")
PROJECT_PREFIX="harvester"

# ARCH: Target architecture (amd64 for x86_64)
ARCH="amd64"

# ARTIFACTS_DIR: Directory containing build artifacts
# Contains the ISO, kernel, initrd generated by the main build
ARTIFACTS_DIR="harvester-build/harvester-installer/dist/artifacts"

# VM_MEMORY: RAM allocated to the QEMU VM during installation
# Defaults to 8192 (8GB), but will be adjusted dynamically if host RAM is low
VM_MEMORY=8192

# ============================================================================
# Helper Functions
# ============================================================================

log() {
    echo -e "\n\033[1;32m[INFO]\033[0m $1"
}

warn() {
    echo -e "\n\033[1;33m[WARN]\033[0m $1"
}

error() {
    echo -e "\n\033[1;31m[ERROR]\033[0m $1"
    exit 1
}

cleanup() {
    # This function is called on exit to clean up temp files
    if [ -n "$TEMP_OVMF_VARS" ] && [ -f "$TEMP_OVMF_VARS" ]; then
        rm -f "$TEMP_OVMF_VARS"
    fi
}
trap cleanup EXIT

# ============================================================================
# Step 0: Pre-flight Checks
# ============================================================================
log "Step 0: Pre-flight checks..."

# Check for required tools
for tool in qemu-system-x86_64 qemu-img zstd; do
    if ! command -v "$tool" &> /dev/null; then
        error "Required tool '$tool' is not installed."
    fi
done

# Check KVM availability
if [ -e /dev/kvm ] && [ -r /dev/kvm ] && [ -w /dev/kvm ]; then
    echo "  KVM is available and accessible."
else
    error "KVM (/dev/kvm) is not accessible. Please ensure hardware virtualization is enabled and your user has permission (e.g., add to 'kvm' or 'libvirt' group)."
fi

# ============================================================================
# Step 1: Automatic Version Detection
# ============================================================================
# If VERSION is not defined, try to detect it automatically
# by looking for the most recent ISO file in the artifacts directory.
# ============================================================================
if [ -z "$VERSION" ]; then
  # Find the most recent ISO file (sorted by date, newest first)
  ISO_FILE=$(ls -t ${ARTIFACTS_DIR}/harvester-*-${ARCH}.iso 2>/dev/null | head -1)
  
  if [ -n "$ISO_FILE" ]; then
    # Extract version from filename using regex
    # Example: "harvester-v1.7.0-amd64.iso" -> "v1.7.0"
    VERSION=$(basename "$ISO_FILE" | sed "s/harvester-\(.*\)-${ARCH}\.iso/\1/")
    PROJECT_PREFIX="harvester-${VERSION}"
    log "Auto-detected version: $VERSION"
  else
    error "Could not find ISO file in ${ARTIFACTS_DIR}/. Please set VERSION manually or build the ISO first with 'make'."
  fi
else
  PROJECT_PREFIX="harvester-${VERSION}"
fi

log "Building EFI raw image for: ${PROJECT_PREFIX}"

# ============================================================================
# Step 2: Locating OVMF Firmware for UEFI Boot
# ============================================================================
# OVMF (Open Virtual Machine Firmware) is required for EFI/UEFI boot.
#
# Search order (most specific to most generic):
# 1. Separate CODE/VARS files (Preferred: allows NVRAM modification)
# 2. Combined file (Fallback)
# ============================================================================
log "Step 2: Locating OVMF firmware..."

# Define potential paths for OVMF split files (Code, Vars)
# Order: openSUSE/Fedora -> Debian/Ubuntu -> Arch/Generic
OVMF_PATHS=(
    "/usr/share/qemu/ovmf-x86_64-code.bin:/usr/share/qemu/ovmf-x86_64-vars.bin"
    "/usr/share/OVMF/OVMF_CODE.fd:/usr/share/OVMF/OVMF_VARS.fd"
    "/usr/share/OVMF/OVMF_CODE_4M.fd:/usr/share/OVMF/OVMF_VARS_4M.fd"
    "/usr/share/edk2-ovmf/x64/OVMF_CODE.fd:/usr/share/edk2-ovmf/x64/OVMF_VARS.fd"
)

USE_SEPARATE_VARS=false
OVMF_CODE=""
OVMF_VARS=""

for path_pair in "${OVMF_PATHS[@]}"; do
    IFS=":" read -r code vars <<< "$path_pair"
    if [ -f "$code" ] && [ -f "$vars" ]; then
        OVMF_CODE="$code"
        OVMF_VARS="$vars"
        USE_SEPARATE_VARS=true
        echo "  Found separate files: $code, $vars"
        break
    fi
done

# Fallback to combined file if no split files found
if [ -z "$OVMF_CODE" ]; then
    if [ -f /usr/share/OVMF/OVMF.fd ]; then
        OVMF_CODE="/usr/share/OVMF/OVMF.fd"
        echo "  Found combined file: $OVMF_CODE"
    elif [ -f /usr/share/ovmf/OVMF.fd ]; then
        OVMF_CODE="/usr/share/ovmf/OVMF.fd"
        echo "  Found combined file: $OVMF_CODE"
    else
        error "OVMF firmware not found. Please install 'ovmf', 'qemu-ovmf', or 'edk2-ovmf' package."
    fi
fi

# ============================================================================
# Step 3: Verifying Required Files
# ============================================================================
# Check that ISO, Kernel, and Initrd exist before proceeding.
# ============================================================================
log "Step 3: Verifying required files..."

ISO_FILE="${ARTIFACTS_DIR}/${PROJECT_PREFIX}-${ARCH}.iso"
KERNEL_FILE="${ARTIFACTS_DIR}/${PROJECT_PREFIX}-vmlinuz-${ARCH}"
INITRD_FILE="${ARTIFACTS_DIR}/${PROJECT_PREFIX}-initrd-${ARCH}"

for file in "$ISO_FILE" "$KERNEL_FILE" "$INITRD_FILE"; do
  if [ ! -f "$file" ]; then
    error "Required file not found: $file. Please build the ISO first."
  fi
done
echo "  All required files found."

# ============================================================================
# Step 4: Creating Raw Disk Image
# ============================================================================
# Create a 250GB raw disk image. This will be the target drive for Harvester.
# It is created as a sparse file (taking up minimal actual space initially).
# ============================================================================
log "Step 4: Creating raw disk image..."
RAW_FILE="${ARTIFACTS_DIR}/${PROJECT_PREFIX}-${ARCH}.raw"

if [ -f "$RAW_FILE" ]; then
  read -p "Raw image already exists. Overwrite? (y/N): " -n 1 -r
  echo
  if [[ ! $REPLY =~ ^[Yy]$ ]]; then
    error "Aborted by user."
  fi
  rm -f "$RAW_FILE"
fi

qemu-img create -f raw -o size=250G "$RAW_FILE"
echo "  Created: $RAW_FILE"

# ============================================================================
# Step 5: Preparing OVMF VARS (If using separate files)
# ============================================================================
# Create a temporary copy of VARS so QEMU can write NVRAM changes without
# affecting the system file.
# ============================================================================
if [ "$USE_SEPARATE_VARS" = true ]; then
  TEMP_OVMF_VARS=$(mktemp)
  cp "$OVMF_VARS" "$TEMP_OVMF_VARS"
  chmod 644 "$TEMP_OVMF_VARS"
  echo "  Created temporary OVMF VARS: $TEMP_OVMF_VARS"
fi

# ============================================================================
# Step 6: Building and Executing QEMU Command
# ============================================================================
log "Step 6: Starting QEMU installation..."

# Check available host RAM to avoid OOM
HOST_RAM_KB=$(grep MemTotal /proc/meminfo | awk '{print $2}')
if [ "$HOST_RAM_KB" -lt 8500000 ]; then
    warn "Host has less than 8.5GB RAM. Reducing VM memory to 4GB. Installation may be slower."
    VM_MEMORY=4096
fi

# Base QEMU command
# -machine q35: Modern chipset required for proper UEFI support
# -cpu host: Passthrough host CPU features
QEMU_CMD="qemu-system-x86_64 -machine q35,accel=kvm -cpu host -smp cores=2,threads=2,sockets=1 -m ${VM_MEMORY}"
QEMU_CMD="$QEMU_CMD -nographic -serial mon:stdio -serial file:harvester-installer.log -nic none"

# Firmware Configuration
if [ "$USE_SEPARATE_VARS" = true ]; then
  QEMU_CMD="$QEMU_CMD -drive if=pflash,format=raw,readonly=on,file=${OVMF_CODE}"
  QEMU_CMD="$QEMU_CMD -drive if=pflash,format=raw,file=${TEMP_OVMF_VARS}"
else
  QEMU_CMD="$QEMU_CMD -bios ${OVMF_CODE}"
fi

# Storage Configuration
QEMU_CMD="$QEMU_CMD -drive file=${RAW_FILE},if=virtio,cache=writeback,discard=ignore,format=raw"
QEMU_CMD="$QEMU_CMD -cdrom ${ISO_FILE}"
QEMU_CMD="$QEMU_CMD -kernel ${KERNEL_FILE}"

# Kernel Parameters for Automatic Installation
# - harvester.install.automatic=true: No user interaction required
# - harvester.install.powerOff=true: Shutdown VM immediately after success
# - console=ttyS1: Redirect logs to serial port for capture
CMDLINE="cdroot root=live:CDLABEL=COS_LIVE rd.live.dir=/ rd.live.squashimg=rootfs.squashfs console=ttyS1 rd.cos.disable net.ifnames=1 harvester.install.mode=install harvester.install.device=/dev/vda harvester.install.automatic=true harvester.install.powerOff=true harvester.os.password=rancher harvester.scheme_version=1 harvester.install.persistentPartitionSize=150Gi harvester.install.skipchecks=true"

QEMU_CMD="$QEMU_CMD -append \"$CMDLINE\""
QEMU_CMD="$QEMU_CMD -initrd ${INITRD_FILE} -boot once=d"

echo "  Running installation (this may take several minutes)..."
eval $QEMU_CMD

# ============================================================================
# Step 7: Verification and Cleanup
# ============================================================================
log "Step 7: verifying installation..."

echo "Installation log (last 50 lines):"
echo "---------------------------------"
tail -50 harvester-installer.log || true
echo "---------------------------------"

if [ ! -f "$RAW_FILE" ]; then
  error "Raw image file not found after installation."
fi

FILE_SIZE=$(stat -c%s "$RAW_FILE" 2>/dev/null || stat -f%z "$RAW_FILE" 2>/dev/null)
if [ "$FILE_SIZE" -eq 0 ]; then
  error "Raw image file is empty."
fi

# Optional: Verify partition table
echo "  Verifying partition table..."
parted "$RAW_FILE" print || warn "Could not read partition table (may need root access)."

# ============================================================================
# Step 8: Compression
# ============================================================================
log "Step 8: Compressing raw image..."
COMPRESSED_FILE="${RAW_FILE}.zst"

if [ -f "$COMPRESSED_FILE" ]; then
  rm -f "$COMPRESSED_FILE"
fi

# Compress with zstd (multithreaded)
zstd -T4 --rm "$RAW_FILE"
echo "  Created compressed image: $COMPRESSED_FILE"

log "Build completed successfully!"
